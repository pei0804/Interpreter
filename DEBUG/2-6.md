# 変数宣言 Parser
```go
func TestString(t *testing.T) {
	program := &Program{
		Statements: []Statement{
			&LetStatement{
				Token: token.Token{Type: token.LET, Literal: "let"},
				Name: &Identifier{
					Token: token.Token{Type: token.IDENT, Literal: "myVar"},
					Value: "myVar",
				},
				Value: &Identifier{
					Token: token.Token{Type: token.IDENT, Literal: "anotherVar"},
					Value: "anotherVar",
				},
			},
		},
	}

	if program.String() != "let myVar = anotherVar;" {
		t.Errorf("program.String() wrong. got=%q", program.String())
	}
}

// let myVar = anotherVar を取り出す
> app/ast.(*Program).String() ./ast.go:30 (PC: 0x10f007e)
    25: }
    26:
    27: func (p *Program) String() string {
    28:         var out bytes.Buffer
    29:         for _, s := range p.Statements {
=>  30:                 out.WriteString(s.String())
    31:         }
    32:         return out.String()
    33: }
    34:
    35: // TokenLiteral 関連付けられている文字列を取得する
(dlv) p s
app/ast.Statement(*app/ast.LetStatement) *{
        Token: app/token.Token {Type: "LET", Literal: "let"},
        Name: *app/ast.Identifier {
                Token: (*app/token.Token)(0xc420074900),
                Value: "myVar",},
        Value: app/ast.Expression(*app/ast.Identifier) *{
                Token: (*app/token.Token)(0xc4200748d0),
                Value: "anotherVar",},}
(dlv)

> app/ast.(*LetStatement).String() ./ast.go:57 (PC: 0x10f02d6)
    52: // TokenLiteral 関連付けられている文字列を取得する
    53: func (ls *LetStatement) TokenLiteral() string { return ls.Token.Literal }
    54: func (ls *LetStatement) String() string {
    55:         var out bytes.Buffer
    56:
                // let
=>  57:         out.WriteString(ls.TokenLiteral() + " ")
                // myVar
    58:         out.WriteString(ls.Name.String())
    59:         out.WriteString(" = ")
    60:
    61:         if ls.Value != nil {
                        // anotherVar
    62:                 out.WriteString(ls.Value.String())
(dlv) s
```

```go
// 変数の妥当性
func TestIdentifierExpression(t *testing.T) {
	input := "foobar;"
	l := lexer.New(input)
	p := New(l)
	program := p.ParseProgram()
	checkParserErrors(t, p)
	if len(program.Statements) != 1 {
		t.Fatalf("program has not enough statements. got=%d",
			len(program.Statements))
	}
	stmt, ok := program.Statements[0].(*ast.ExpressionStatement)
	if !ok {
		t.Fatalf("program.Statements[0] is not ast.ExpressionStatement. got=%T",
			program.Statements[0])
	}

	ident, ok := stmt.Expression.(*ast.Identifier)
	if !ok {
		t.Fatalf("exp not *ast.Identifier. got=%T", stmt.Expression)
	}
	if ident.Value != "foobar" {
		t.Errorf("ident.Value not %s. got=%s", "foobar", ident.Value)
	}
	if ident.TokenLiteral() != "foobar" {
		t.Errorf("ident.TokenLiteral not %s. got=%s", "foobar",
			ident.TokenLiteral())
	}
}

// 変数宣言が正しいか調べる
> app/parser.(*Parser).ParseProgram() ./parser.go:77 (PC: 0x10f2588)
    72:         p.curToken = p.peekToken
    73:         p.peekToken = p.l.NextToken()
    74: }
    75:
    76: // ParseProgram EOFになるまで解析する
=>  77: func (p *Parser) ParseProgram() *ast.Program {
    78:         program := &ast.Program{}
    79:         program.Statements = []ast.Statement{}
    80:         for p.curToken.Type != token.EOF {
    81:                 stmt := p.parseStatement()
    82:                 if stmt != nil {
(dlv) p p
*app/parser.Parser {
        l: *app/lexer.Lexer {input: "foobar;", position: 7, readPosition: 8, ch: 0},
        curToken: app/token.Token {Type: "IDENT", Literal: "foobar"},
        peekToken: app/token.Token {Type: ";", Literal: ";"},
        errors: []string len: 0, cap: 0, [],
        prefixParseFns: map[app/token.TokenType]app/parser.prefixParseFn [
                "IDENT": app/parser.(*Parser).(app/parser.parseIdentifier)-fm,
        ],
        infixParseFns: map[app/token.TokenType]app/parser.infixParseFn nil,}
(dlv)
> app/parser.(*Parser).parseStatement() ./parser.go:91 (PC: 0x10f2873)
    86:         }
    87:         return program
    88: }
    89:
    90: // parseStatement それぞれの構文チェックをする
=>  91: func (p *Parser) parseStatement() ast.Statement {
    92:         switch p.curToken.Type {
    93:         case token.LET:
    94:                 return p.parseLetStatement()
    95:         case token.RETURN:
    96:                 return p.parseReturnStatement()
(dlv)
// 今回は変数宣言でもなく、return句でもないので、defaultになる
> app/parser.(*Parser).parseStatement() ./parser.go:98 (PC: 0x10f2a05)
    93:         case token.LET:
    94:                 return p.parseLetStatement()
    95:         case token.RETURN:
    96:                 return p.parseReturnStatement()
    97:         default:
=>  98:                 return p.parseExpressionStatement()
    99:         }
   100: }
   101:
   102: // parseLetStatement 変数宣言の構文チェックをする
   103: func (p *Parser) parseLetStatement() *ast.LetStatement {
(dlv)

// 一番優先度が低い
func (p *Parser) parseExpressionStatement() *ast.ExpressionStatement {
	stmt := &ast.ExpressionStatement{Token: p.curToken}

	stmt.Expression = p.parseExpression(LOWEST)

	if p.peekTokenIs(token.SEMICOLON) {
		p.nextToken()
	}

	return stmt
}

(dlv) p stmt
*app/ast.ExpressionStatement {
        Token: app/token.Token {Type: "IDENT", Literal: "foobar"},
        Expression: app/ast.Expression(*app/ast.Identifier) *{
                Token: (*app/token.Token)(0xc420078b40),
                Value: "foobar",},}
(dlv)

// 変数宣言チェック
// 値が正しい型か
> app/parser.TestIdentifierExpression() ./parser_test.go:83 (PC: 0x10f410f)
    78:         checkParserErrors(t, p)
    79:         if len(program.Statements) != 1 {
    80:                 t.Fatalf("program has not enough statements. got=%d",
    81:                         len(program.Statements))
    82:         }
=>  83:         stmt, ok := program.Statements[0].(*ast.ExpressionStatement)
    84:         if !ok {
    85:                 t.Fatalf("program.Statements[0] is not ast.ExpressionStatement
. got=%T",
    86:                         program.Statements[0])
    87:         }
    88:
(dlv) p program.Statements[0]
app/ast.Statement(*app/ast.ExpressionStatement) *{
        Token: app/token.Token {Type: "IDENT", Literal: "foobar"},
        Expression: app/ast.Expression(*app/ast.Identifier) *{
                Token: (*app/token.Token)(0xc420078b40),
                Value: "foobar",},}

// 実際の値がfoobarか
> app/parser.TestIdentifierExpression() ./parser_test.go:96 (PC: 0x10f4147)
    91:                 t.Fatalf("exp not *ast.Identifier. got=%T", stmt.Expression)
    92:         }
    93:         if ident.Value != "foobar" {
    94:                 t.Errorf("ident.Value not %s. got=%s", "foobar", ident.Value)
    95:         }
=>  96:         if ident.TokenLiteral() != "foobar" {
    97:                 t.Errorf("ident.TokenLiteral not %s. got=%s", "foobar",
    98:                         ident.TokenLiteral())
    99:         }
   100: }
   101:
(dlv)
```

# Integer 

```go
func New(l *lexer.Lexer) *Parser {
	p := &Parser{
		l:      l,
		errors: []string{},
	}

	p.prefixParseFns = make(map[token.TokenType]prefixParseFn)
	p.registerPrefix(token.IDENT, p.parseIdentifier)
  // これ重要
	p.registerPrefix(token.INT, p.parseIntegerLiteral)

	// Read two tokens, so curToken and peekToken are both set
	p.nextToken()
	p.nextToken()

	return p
}

> app/parser.(*Parser).ParseProgram() ./parser.go:83 (PC: 0x10f28be)
    78: // ParseProgram EOFになるまで解析する
    79: func (p *Parser) ParseProgram() *ast.Program {
    80:         program := &ast.Program{}
    81:         program.Statements = []ast.Statement{}
    82:         for p.curToken.Type != token.EOF {
=>  83:                 stmt := p.parseStatement()
    84:                 if stmt != nil {
    85:                         program.Statements = append(program.Statements, stmt)
    86:                 }
    87:                 p.nextToken()
    88:         }
(dlv) s

// let句でもreturn句でもないので、expressionに入る
> app/parser.(*Parser).parseStatement() ./parser.go:100 (PC: 0x10f2c55)
    95:         case token.LET:
    96:                 return p.parseLetStatement()
    97:         case token.RETURN:
    98:                 return p.parseReturnStatement()
    99:         default:
=> 100:                 return p.parseExpressionStatement()
   101:         }
   102: }
   103:
   104: // parseLetStatement 変数宣言の構文チェックをする
   105: func (p *Parser) parseLetStatement() *ast.LetStatement {
(dlv)


> app/parser.(*Parser).parseExpression() ./parser.go:174 (PC: 0x10f3833)
   169: func (p *Parser) parseIdentifier() ast.Expression {
   170:         return &ast.Identifier{Token: p.curToken, Value: p.curToken.Literal}
   171: }
   172:
   173: func (p *Parser) parseExpression(precedence int) ast.Expression {
=> 174:         prefix := p.prefixParseFns[p.curToken.Type]
   175:         if prefix == nil {
   176:                 return nil
   177:         }
   178:         leftExp := prefix()
   179:
(dlv) p p.curToken.Type
"INT"

// INT型なので、以下のメソッドが実行される
func (p *Parser) parseIntegerLiteral() ast.Expression {
	lit := &ast.IntegerLiteral{Token: p.curToken}

	value, err := strconv.ParseInt(p.curToken.Literal, 0, 64)
	if err != nil {
		msg := fmt.Sprintf("could not parse %q as integer", p.curToken.Literal)
		p.errors = append(p.errors, msg)
		return nil
	}

	lit.Value = value

	return lit
}
```

# prefix

```go
// New コンストラクタ
// 最初の段階で最初のtokenと次のtokenが必要なので、内部で2回 nextTokenが実行される
func New(l *lexer.Lexer) *Parser {
	p := &Parser{
		l:      l,
		errors: []string{},
	}

	p.prefixParseFns = make(map[token.TokenType]prefixParseFn)
	p.registerPrefix(token.IDENT, p.parseIdentifier)
	p.registerPrefix(token.INT, p.parseIntegerLiteral)
  // 新たに追加
	p.registerPrefix(token.BANG, p.parsePrefixExpression)
	p.registerPrefix(token.MINUS, p.parsePrefixExpression)
  // 新たに追加

	// Read two tokens, so curToken and peekToken are both set
	p.nextToken()
	p.nextToken()

	return p
}
// registerPrefixでparseFnsに追加する
// 根気の場合、token.BANGとtoken.MINUSに注目すればおｋ
func (p *Parser) registerPrefix(tokenType token.TokenType, fn prefixParseFn) {
	p.prefixParseFns[tokenType] = fn
}

// parseする
> app/parser.(*Parser).ParseProgram() ./parser.go:85 (PC: 0x10f2d8e)
    80: // ParseProgram EOFになるまで解析する
    81: func (p *Parser) ParseProgram() *ast.Program {
    82:         program := &ast.Program{}
    83:         program.Statements = []ast.Statement{}
    84:         for p.curToken.Type != token.EOF {
=>  85:                 stmt := p.parseStatement()
    86:                 if stmt != nil {
    87:                         program.Statements = append(program.Statements, stmt)
    88:                 }
    89:                 p.nextToken()
    90:         }
(dlv)

// expressionに入る
> app/parser.(*Parser).parseStatement() ./parser.go:102 (PC: 0x10f3125)
    97:         case token.LET:
    98:                 return p.parseLetStatement()
    99:         case token.RETURN:
   100:                 return p.parseReturnStatement()
   101:         default:
=> 102:                 return p.parseExpressionStatement()
   103:         }
   104: }
   105:
   106: func (p *Parser) parsePrefixExpression() ast.Expression {
   107:         expression := &ast.PrefixExpression{
(dlv)

> app/parser.(*Parser).parseExpressionStatement() ./parser.go:156 (PC: 0x10f3889)
   151: }
   152:
   153: func (p *Parser) parseExpressionStatement() *ast.ExpressionStatement {
   154:         stmt := &ast.ExpressionStatement{Token: p.curToken}
   155:
=> 156:         stmt.Expression = p.parseExpression(LOWEST)
   157:
   158:         // 現在のtokenの次がセミコロンだった場合、次に進める
   159:         // つまり、foobar;だけなら、statementにはfoobarしか入らない
   160:         if p.peekTokenIs(token.SEMICOLON) {
   161:                 p.nextToken()
(dlv) s

// ! が入ってるので該当する関数がある
> app/parser.(*Parser).parseExpression() ./parser.go:192 (PC: 0x10f4173)
   187:         return &ast.Identifier{Token: p.curToken, Value: p.curToken.Literal}
   188: }
   189:
   190: func (p *Parser) parseExpression(precedence int) ast.Expression {
   191:         prefix := p.prefixParseFns[p.curToken.Type]
=> 192:         if prefix == nil {
   193:                 p.noPrefixParseFnError(p.curToken.Type)
   194:                 return nil
   195:         }
   196:         leftExp := prefix()
   197:         return leftExp
(dlv) s
(dlv) p p.curToken.Type
"!"

> app/parser.(*Parser).parsePrefixExpression() ./parser.go:109 (PC: 0x10f31d3)
   104: }
   105:
   106: func (p *Parser) parsePrefixExpression() ast.Expression {
   107:         expression := &ast.PrefixExpression{
   108:                 Token:    p.curToken,
=> 109:                 Operator: p.curToken.Literal,
   110:         }
   111:         p.nextToken()
   112:         expression.Right = p.parseExpression(PREFIX)
   113:         return expression
   114: }
(dlv) p p.curToken
app/token.Token {Type: "!", Literal: "!"}
(dlv) p p.curToken.Literal
"!"
(dlv)
// 次のtokenを取得し、PREFIXの次の文字列を取得する
// この場合、! の次にあるのは 5を想定している
> app/parser.(*Parser).parsePrefixExpression() ./parser.go:111 (PC: 0x10f3294)
   106: func (p *Parser) parsePrefixExpression() ast.Expression {
   107:         expression := &ast.PrefixExpression{
   108:                 Token:    p.curToken,
   109:                 Operator: p.curToken.Literal,
   110:         }
=> 111:         p.nextToken()
   112:         expression.Right = p.parseExpression(PREFIX)
   113:         return expression
   114: }
   115:
   116: // parseLetStatement 変数宣言の構文チェックをする
(dlv)
*app/parser.Parser {
        l: *app/lexer.Lexer {input: "!5;", position: 2, readPosition: 3, ch: 59},
        curToken: app/token.Token {Type: "!", Literal: "!"},
        peekToken: app/token.Token {Type: "INT", Literal: "5"},
        errors: []string len: 0, cap: 0, [],
        prefixParseFns: map[app/token.TokenType]app/parser.prefixParseFn [
                "IDENT": app/parser.(*Parser).(app/parser.parseIdentifier)-fm,
                "INT": app/parser.(*Parser).(app/parser.parseIdentifier)-fm,
                "!": app/parser.(*Parser).(app/parser.parseIdentifier)-fm,
                "-": app/parser.(*Parser).(app/parser.parseIdentifier)-fm,
        ],
        infixParseFns: map[app/token.TokenType]app/parser.infixParseFn nil,}

// 正しく取得出来ていることがわかる
*app/parser.Parser {
        l: *app/lexer.Lexer {input: "!5;", position: 3, readPosition: 4, ch: 0},
        curToken: app/token.Token {Type: "INT", Literal: "5"},
        peekToken: app/token.Token {Type: ";", Literal: ";"},
        errors: []string len: 0, cap: 0, [],
        prefixParseFns: map[app/token.TokenType]app/parser.prefixParseFn [
                "IDENT": app/parser.(*Parser).(app/parser.parseIdentifier)-fm,
                "INT": app/parser.(*Parser).(app/parser.parseIdentifier)-fm,
                "!": app/parser.(*Parser).(app/parser.parseIdentifier)-fm,
                "-": app/parser.(*Parser).(app/parser.parseIdentifier)-fm,
        ],
        infixParseFns: map[app/token.TokenType]app/parser.infixParseFn nil,}
(dlv)

// 演算子の右に来る式を判定する
> app/parser.(*Parser).parsePrefixExpression() ./parser.go:112 (PC: 0x10f32a2)
   107:         expression := &ast.PrefixExpression{
   108:                 Token:    p.curToken,
   109:                 Operator: p.curToken.Literal,
   110:         }
   111:         p.nextToken()
=> 112:         expression.Right = p.parseExpression(PREFIX)
   113:         return expression
   114: }
   115:
   116: // parseLetStatement 変数宣言の構文チェックをする

*app/parser.Parser {
   190: func (p *Parser) parseExpression(precedence int) ast.Expression {
=> 191:         prefix := p.prefixParseFns[p.curToken.Type]
   192:         if prefix == nil {
   193:                 p.noPrefixParseFnError(p.curToken.Type)
   194:                 return nil
   195:         }
   196:         leftExp := prefix()
(dlv) p p.curToken.Type
"INT"
(dlv)

// 優先順位でいうと上から二番目
// const (
// 	_ int = iota
// 	LOWEST
// 	EQUALS      // ==
// 	LESSGREATER // > or <
// 	SUM         // +
// 	PRODUCT     // *
// 	PREFIX      // -X or !X
// 	CALL        // myFunction(X)
// )
> app/parser.(*Parser).parseExpression() ./parser.go:192 (PC: 0x10f4173)
   187:         return &ast.Identifier{Token: p.curToken, Value: p.curToken.Literal}
   188: }
   189:
   190: func (p *Parser) parseExpression(precedence int) ast.Expression {
   191:         prefix := p.prefixParseFns[p.curToken.Type]
=> 192:         if prefix == nil {
   193:                 p.noPrefixParseFnError(p.curToken.Type)
   194:                 return nil
   195:         }
   196:         leftExp := prefix()
   197:         return leftExp
(dlv) s

// 実行される関数はINT
> app/parser.(*Parser).parseExpression() ./parser.go:196 (PC: 0x10f417a)
   191:         prefix := p.prefixParseFns[p.curToken.Type]
   192:         if prefix == nil {
   193:                 p.noPrefixParseFnError(p.curToken.Type)
   194:                 return nil
   195:         }
=> 196:         leftExp := prefix()
   197:         return leftExp
   198: }
   199:
   200: // curTokenIs 引数のtokenTypeと現在のcurTokenのtypeが同じか調べる
   201: func (p *Parser) curTokenIs(t token.TokenType) bool {
(dlv) p p.curToken.Type
"INT"
(dlv)

> app/parser.(*Parser).ParseProgram() ./parser.go:87 (PC: 0x10f2dbd)
    82:         program := &ast.Program{}
    83:         program.Statements = []ast.Statement{}
    84:         for p.curToken.Type != token.EOF {
    85:                 stmt := p.parseStatement()
    86:                 if stmt != nil {
=>  87:                         program.Statements = append(program.Statements, stmt)
    88:                 }
    89:                 p.nextToken()
    90:         }
    91:         return program
    92: }
(dlv) p stmt
app/ast.Statement(*app/ast.ExpressionStatement) *{
        Token: app/token.Token {Type: "!", Literal: "!"},
        Expression: app/ast.Expression(*app/ast.PrefixExpression) *{
                Token: (*app/token.Token)(0xc420013300),
                Operator: "!",
                Right: app/ast.Expression(*app/ast.IntegerLiteral) ...,},}
(dlv)

// 返ってきた値の妥当性
> app/parser.TestParsingPrefixExpressions() ./parser_test.go:165 (PC: 0x10f653d)
   160:
   161:                 exp, ok := stmt.Expression.(*ast.PrefixExpression)
   162:                 if !ok {
   163:                         t.Fatalf("stmt is not ast.PrefixExpression. got=%T",
stmt.Expression)
   164:                 }
=> 165:                 if exp.Operator != tt.operator {
   166:                         t.Fatalf("exp.Operator is not '%s'. got=%s",
   167:                                 tt.operator, exp.Operator)
   168:                 }
   169:                 if !testIntegerLiteral(t, exp.Right, tt.integerValue) {
   170:                         return
(dlv) p exp
*app/ast.PrefixExpression {
        Token: app/token.Token {Type: "!", Literal: "!"},
        Operator: "!",
        Right: app/ast.Expression(*app/ast.IntegerLiteral) *{
                Token: (*app/token.Token)(0xc420018e10),
                Value: 5,},}
(dlv)

// Operatorの右にある式が想定した値かどうか
> app/parser.testIntegerLiteral() ./parser_test.go:220 (PC: 0x10f75c5)
   215:         if !ok {
   216:                 t.Errorf("il not *ast.IntegerLiteral. got=%T", il)
   217:                 return false
   218:         }
   219:
=> 220:         if integ.Value != value {
   221:                 t.Errorf("integ.Value not %d. got=%d", value, integ.Value)
   222:                 return false
   223:         }
   224:
   225:         if integ.TokenLiteral() != fmt.Sprintf("%d", value) {
   226:                 t.Errorf("integ.TokenLiteral not %d. got=%s", value,
   227:                         integ.TokenLiteral())
   228:                 return false
   229:         }
   230:
(dlv)
(dlv) p integ
*app/ast.IntegerLiteral {
        Token: app/token.Token {Type: "INT", Literal: "5"},
        Value: 5,}
(dlv)
```

Prefixがついている場合は、最終的にRightに正しく値が入っているかが重要。そして、Prefixはかなり優先度高めなので、そこらへんの処理も重要。

# infix

```go
// {"5 + 5;", 5, "+", 5},
> app/parser.TestParsingInfixExpressions() ./parser_test
.go:195 (hits goroutine(10):1 total:1) (PC: 0x10f7b29)
   190:         }
   191:
   192:         for _, tt := range infixTests {
   193:                 l := lexer.New(tt.input)
   194:                 p := New(l)
=> 195:                 program := p.ParseProgram()
   196:                 checkParserErrors(t, p)
   197:
   198:                 if len(program.Statements) != 1
{
   199:                         t.Fatalf("program.Statem
ents does not contain %d statements. got=%d\n",
   200:                                 1, len(program.S
tatements))
(dlv) s
// EOFになるまで繰り返す
> app/parser.(*Parser).ParseProgram() ./parser.go:118 (PC: 0x10f39ed)
   113:
   114: // ParseProgram EOFになるまで解析する
   115: func (p *Parser) ParseProgram() *ast.Program {
   116:         program := &ast.Program{}
   117:         program.Statements = []ast.Statement{}
=> 118:         for p.curToken.Type != token.EOF {
   119:                 stmt := p.parseStatement()
   120:                 if stmt != nil {
   121:                         program.Statements = append(program.Statements, stmt)
   122:                 }
   123:                 p.nextToken()
(dlv) n

// 一回目のparse開始
> app/parser.(*Parser).ParseProgram() ./parser.go:119 (PC: 0x10f38be)
   114: // ParseProgram EOFになるまで解析する
   115: func (p *Parser) ParseProgram() *ast.Program {
   116:         program := &ast.Program{}
   117:         program.Statements = []ast.Statement{}
   118:         for p.curToken.Type != token.EOF {
=> 119:                 stmt := p.parseStatement()
   120:                 if stmt != nil {
   121:                         program.Statements = append(program.Statements, stmt)
   122:                 }
   123:                 p.nextToken()
   124:         }
(dlv) p p.curToken
app/token.Token {Type: "INT", Literal: "5"}

// INTなので、parseExpressionStatementが選ばれる
app/token.Token {Type: "INT", Literal: "5"}
> app/parser.(*Parser).parseStatement() ./parser.go:136 (PC: 0x10f3c55)
   131:         case token.LET:
   132:                 return p.parseLetStatement()
   133:         case token.RETURN:
   134:                 return p.parseReturnStatement()
   135:         default:
=> 136:                 return p.parseExpressionStatement()
   137:         }
   138: }
   139:
   140: func (p *Parser) parsePrefixExpression() ast.Expression {
   141:         expression := &ast.PrefixExpression{
(dlv)

// 優先順位LOWESTでapp/token.Token {Type: "INT", Literal: "5"}を解釈する
> app/parser.(*Parser).parseExpressionStatement() ./parser.go:190 (PC: 0x10f43b9)
   185: }
   186:
   187: func (p *Parser) parseExpressionStatement() *ast.ExpressionStatement {
   188:         stmt := &ast.ExpressionStatement{Token: p.curToken}
   189:
=> 190:         stmt.Expression = p.parseExpression(LOWEST)
   191:
   192:         // 現在のtokenの次がセミコロンだった場合、次に進める
   193:         // つまり、foobar;だけなら、statementにはfoobarしか入らない
   194:         if p.peekTokenIs(token.SEMICOLON) {
   195:                 p.nextToken()
(dlv) s

// prefix()をleftExpに渡す
> app/parser.(*Parser).parseExpression() ./parser.go:242 (PC: 0x10f4ef3)
   237:         prefix := p.prefixParseFns[p.curToken.Type]
   238:         if prefix == nil {
   239:                 p.noPrefixParseFnError(p.curToken.Type)
   240:                 return nil
   241:         }
=> 242:         leftExp := prefix()
   243:
   244:         for !p.peekTokenIs(token.SEMICOLON) && precedence < p.peekPrecedence()
 {
   245:                 infix := p.infixParseFns[p.peekToken.Type]
   246:                 if infix == nil {
   247:                         return leftExp
(dlv) s

// が渡されるp.registerPrefix(token.INT, p.parseIntegerLiteral)
> app/parser.(*Parser).(app/parser.parseIntegerLiteral)-fm() ./parser.go:65 (PC: 0x10f
9a5f)
    60:                 errors: []string{},
    61:         }
    62:
    63:         p.prefixParseFns = make(map[token.TokenType]prefixParseFn)
    64:         p.registerPrefix(token.IDENT, p.parseIdentifier)
=>  65:         p.registerPrefix(token.INT, p.parseIntegerLiteral)
    66:         p.registerPrefix(token.BANG, p.parsePrefixExpression)
    67:         p.registerPrefix(token.MINUS, p.parsePrefixExpression)
    68:         p.infixParseFns = make(map[token.TokenType]infixParseFn)
    69:         p.registerInfix(token.PLUS, p.parseInfixExpression)
    70:         p.registerInfix(token.MINUS, p.parseInfixExpression)
(dlv) s
// 内容はintにキャスト
> app/parser.(*Parser).parseIntegerLiteral() ./parser.go:200 (PC: 0x10f44c8)
   195:                 p.nextToken()
   196:         }
   197:
   198:         return stmt
   199: }
=> 200: func (p *Parser) parseIntegerLiteral() ast.Expression {
   201:         lit := &ast.IntegerLiteral{Token: p.curToken}
   202:
   203:         value, err := strconv.ParseInt(p.curToken.Literal, 0, 64)
   204:         if err != nil {
   205:                 msg := fmt.Sprintf("could not parse %q as integer", p.curToken
.Literal)
(dlv)

// ここからは、次に来るtokenがセミコロンではなく、優先度が現在のものより低い間はループを続ける処理になる
> app/parser.(*Parser).parseExpression() ./parser.go:244 (PC: 0x10f4f0b)
   239:                 p.noPrefixParseFnError(p.curToken.Type)
   240:                 return nil
   241:         }
   242:         leftExp := prefix()
   243:
=> 244:         for !p.peekTokenIs(token.SEMICOLON) && precedence < p.peekPrecedence()
 {
   245:                 infix := p.infixParseFns[p.peekToken.Type]
   246:                 if infix == nil {
   247:                         return leftExp
   248:                 }
   249:                 p.nextToken()
(dlv)
// peekTokenIsは渡されたtokenのtypeと同じかをチェックしている
260: // peekTokenIs 引数のtokenTypeと現在のpeekTokenのtypeが同じか調べる
261: func (p *Parser) peekTokenIs(t token.TokenType) bool {
262:         return p.peekToken.Type == t
263: }
// 今回の場合
// app/token.Token {Type: "INT", Literal: "5"}
// 上記のようになっているので、セミコロンではない

// peekPrecedenceはpeekTokenの優先度情報を取得している
89: func (p *Parser) peekPrecedence() int {
90:         if p, ok := precedences[p.peekToken.Type]; ok {
91:                 return p
92:         }
93:         return LOWEST
94: }

// 今回の場合
// 1 < 4 となり、trueとなる 5というINTよりも+のが優先度が高い
app/token.Token {Type: "INT", Literal: "5"}
(dlv) p precedence
1

(dlv) p p.peekToken
app/token.Token {Type: "+", Literal: "+"}
(dlv) p precedences[p.peekToken.Type]
4
(dlv)

// よって、false && trueとなり、不成立となるためループに入る
for !p.peekTokenIs(token.SEMICOLON) && precedence < p.peekPrecedence()
// 次のtokenをパースしtokenを次に進める
> app/parser.(*Parser).parseExpression() ./parser.go:249 (PC: 0x10f4fc4)
   244:         for !p.peekTokenIs(token.SEMICOLON) && precedence < p.peekPrecedence()
 {
   245:                 infix := p.infixParseFns[p.peekToken.Type]
   246:                 if infix == nil {
   247:                         return leftExp
   248:                 }
=> 249:                 p.nextToken()
   250:                 leftExp = infix(leftExp)
   251:         }
   252:         return leftExp
   253: }
   254:
(dlv) s

// leftExpはにはleftexpを包括した状態で、p.registerInfix(token.PLUS, p.parseInfixExpression)がが入る
> app/parser.(*Parser).(app/parser.parseInfixExpression)-fm() ./parser.go:69 (PC: 0x10
f9b83)
    64:         p.registerPrefix(token.IDENT, p.parseIdentifier)
    65:         p.registerPrefix(token.INT, p.parseIntegerLiteral)
    66:         p.registerPrefix(token.BANG, p.parsePrefixExpression)
    67:         p.registerPrefix(token.MINUS, p.parsePrefixExpression)
    68:         p.infixParseFns = make(map[token.TokenType]infixParseFn)
=>  69:         p.registerInfix(token.PLUS, p.parseInfixExpression)
    70:         p.registerInfix(token.MINUS, p.parseInfixExpression)
    71:         p.registerInfix(token.SLASH, p.parseInfixExpression)
    72:         p.registerInfix(token.ASTERISK, p.parseInfixExpression)
    73:         p.registerInfix(token.EQ, p.parseInfixExpression)
    74:         p.registerInfix(token.NOT_EQ, p.parseInfixExpression)
(dlv)

// infixは以下の情報が入っている 5 + まで認識されている状態になる
*app/ast.InfixExpression {
        Token: app/token.Token {Type: "+", Literal: "+"},
        Left: app/ast.Expression(*app/ast.IntegerLiteral) *{
                Token: (*app/token.Token)(0xc4200a2f00),
                Value: 5,},
        Operator: "+",
        Right: app/ast.Expression(*app/ast.IntegerLiteral) *{
                Token: (*app/token.Token)(0xc4200a2f30),
                Value: 5,},}
(dlv)
> app/parser.(*Parser).parseInfixExpression() ./parser.go:226 (PC: 0x10f4c22)
   220: func (p *Parser) parseInfixExpression(left ast.Expression) ast.Expression {
   221:         expression := &ast.InfixExpression{
   222:                 Token:    p.curToken,
   223:                 Operator: p.curToken.Literal,
   224:                 Left:     left,
   225:         }
=> 226:         precedence := p.curPrecedence()
   227:         p.nextToken()
   228:         expression.Right = p.parseExpression(precedence)
   229:         return expression
   230: }
   231:
(dlv) p expression

// 再度ループ判定に入るが、ここで終了となる。
for !p.peekTokenIs(token.SEMICOLON) && precedence < p.peekPrecedence()
// app/token.Token {Type: ";", Literal: ";"} のため

// 上記の流れで、 5 + 5 ;まで解析完了する
```

# 複雑な式

```go
// 式を解析する -a * b
l: *app/lexer.Lexer {input: "-a * b", position: 2, readPosition: 3, ch: 32}, 
curToken: app/token.Token {Type: "-", Literal: "-"},
peekToken: app/token.Token {Type: "IDENT", Literal: "a"},

// curTokenがEOFになるまで評価し続ける
// curToken: app/token.Token {Type: "-", Literal: "-"},
> app/parser.(*Parser).ParseProgram() ./parser.go:124 (PC: 0x10f38a1)
   119:
   120: // ParseProgram EOFになるまで解析する
   121: func (p *Parser) ParseProgram() *ast.Program {
   122:         program := &ast.Program{}
   123:         program.Statements = []ast.Statement{}
=> 124:         for p.curToken.Type != token.EOF {
   125:                 stmt := p.parseStatement()
   126:                 if stmt != nil {
   127:                         program.Statements = append(program.Statements, stmt)
   128:                 }
   129:                 p.nextToken()
(dlv)

// stmt判定に入る
> app/parser.(*Parser).ParseProgram() ./parser.go:125 (PC: 0x10f38be)
   120: // ParseProgram EOFになるまで解析する
   121: func (p *Parser) ParseProgram() *ast.Program {
   122:         program := &ast.Program{}
   123:         program.Statements = []ast.Statement{}
   124:         for p.curToken.Type != token.EOF {
=> 125:                 stmt := p.parseStatement()
   126:                 if stmt != nil {
   127:                         program.Statements = append(program.Statements, stmt)
   128:                 }
   129:                 p.nextToken()
   130:         }
(dlv) s
> app/parser.(*Parser).parseStatement() ./parser.go:135 (PC: 0x10f3ac3)
   130:         }
   131:         return program
   132: }
   133:
   134: // parseStatement それぞれの構文チェックをする
=> 135: func (p *Parser) parseStatement() ast.Statement {
   136:         switch p.curToken.Type {
   137:         case token.LET:
   138:                 return p.parseLetStatement()
   139:         case token.RETURN:
   140:                 return p.parseReturnStatement()
(dlv)

// Expressionに入る
> app/parser.(*Parser).parseStatement() ./parser.go:142 (PC: 0x10f3c55)
   137:         case token.LET:
   138:                 return p.parseLetStatement()
   139:         case token.RETURN:
   140:                 return p.parseReturnStatement()
   141:         default:
=> 142:                 return p.parseExpressionStatement()
   143:         }
   144: }
   145:
   146: func (p *Parser) parsePrefixExpression() ast.Expression {
   147:         expression := &ast.PrefixExpression{
(dlv) s

// stmtに現在のtokenの情報を入れる
> app/parser.(*Parser).parseExpressionStatement() ./parser.go:193 (PC: 0x10f4313)
   188:                 p.nextToken()
   189:         }
   190:         return stmt
   191: }
   192:
=> 193: func (p *Parser) parseExpressionStatement() *ast.ExpressionStatement {
   194:         stmt := &ast.ExpressionStatement{Token: p.curToken}
   195:
   196:         stmt.Expression = p.parseExpression(LOWEST)
   197:
   198:         // 現在のtokenの次がセミコロンだった場合、次に進める
(dlv) s

// Expressionの判定に入る
> app/parser.(*Parser).parseExpressionStatement() ./parser.go:196 (PC: 0x10f43b9)
   191: }
   192:
   193: func (p *Parser) parseExpressionStatement() *ast.ExpressionStatement {
   194:         stmt := &ast.ExpressionStatement{Token: p.curToken}
   195:
=> 196:         stmt.Expression = p.parseExpression(LOWEST)
   197:
   198:         // 現在のtokenの次がセミコロンだった場合、次に進める
   199:         // つまり、foobar;だけなら、statementにはfoobarしか入らない
   200:         if p.peekTokenIs(token.SEMICOLON) {
   201:                 p.nextToken()
(dlv) s stmt

// 
> app/parser.(*Parser).parseExpression() ./parser.go:245 (PC: 0x10f4e73)
   240:
   241: func (p *Parser) parseIdentifier() ast.Expression {
   242:         return &ast.Identifier{Token: p.curToken, Value: p.curToken.Literal}
   243: }
   244:
=> 245: func (p *Parser) parseExpression(precedence int) ast.Expression {
   246:         prefix := p.prefixParseFns[p.curToken.Type]
   247:         if prefix == nil {
   248:                 p.noPrefixParseFnError(p.curToken.Type)
   249:                 return nil
   250:         }
(dlv) p stmt
Command failed: could not find symbol value for stmt
(dlv) s

// 現在のtokenが特別な振る舞いを持つか調べる
> app/parser.(*Parser).parseExpression() ./parser.go:246 (PC: 0x10f4e99)
   241: func (p *Parser) parseIdentifier() ast.Expression {
   242:         return &ast.Identifier{Token: p.curToken, Value: p.curToken.Literal}
   243: }
   244:
   245: func (p *Parser) parseExpression(precedence int) ast.Expression {
=> 246:         prefix := p.prefixParseFns[p.curToken.Type]
   247:         if prefix == nil {
   248:                 p.noPrefixParseFnError(p.curToken.Type)
   249:                 return nil
   250:         }
   251:         leftExp := prefix()
(dlv) s

// 今回の場合、- は特別な振る舞いを持つため、nilにはならない
> app/parser.(*Parser).parseExpression() ./parser.go:247 (PC: 0x10f4ee9)
   242:         return &ast.Identifier{Token: p.curToken, Value: p.curToken.Literal}
   243: }
   244:
   245: func (p *Parser) parseExpression(precedence int) ast.Expression {
   246:         prefix := p.prefixParseFns[p.curToken.Type]
=> 247:         if prefix == nil {
   248:                 p.noPrefixParseFnError(p.curToken.Type)
   249:                 return nil
   250:         }
   251:         leftExp := prefix()
   252:
(dlv) s

// 関数値をleftExpに代入する
> app/parser.(*Parser).parseExpression() ./parser.go:251 (PC: 0x10f4ef3)
   246:         prefix := p.prefixParseFns[p.curToken.Type]
   247:         if prefix == nil {
   248:                 p.noPrefixParseFnError(p.curToken.Type)
   249:                 return nil
   250:         }
=> 251:         leftExp := prefix()
   252:
   253:         for !p.peekTokenIs(token.SEMICOLON) && precedence < p.peekPrecedence()
 {
   254:                 infix := p.infixParseFns[p.peekToken.Type]
   255:                 if infix == nil {
   256:                         return leftExp
(dlv) args

// 代入された関数値はBANG
> app/parser.(*Parser).(app/parser.parsePrefixExpression)-fm() ./parser.go:66 (PC: 0x1
0f9aef)
    61:         }
    62:
    63:         p.prefixParseFns = make(map[token.TokenType]prefixParseFn)
    64:         p.registerPrefix(token.IDENT, p.parseIdentifier)
    65:         p.registerPrefix(token.INT, p.parseIntegerLiteral)
=>  66:         p.registerPrefix(token.BANG, p.parsePrefixExpression)
    67:         p.registerPrefix(token.MINUS, p.parsePrefixExpression)
    68:         // p.registerPrefix(token.TRUE, p.parseBoolean)
    69:         // p.registerPrefix(token.FALSE, p.parseBoolean)
    70:         // p.registerPrefix(token.LPAREN, p.parseGroupedExpression)
    71:         // p.registerPrefix(token.IF, p.parseIfExpression)
(dlv) s

// 実行に必要な値を格納後、tokenを次に進める
> app/parser.(*Parser).parsePrefixExpression() ./parser.go:151 (PC: 0x10f3dc4)
   146: func (p *Parser) parsePrefixExpression() ast.Expression {
   147:         expression := &ast.PrefixExpression{
   148:                 Token:    p.curToken,
   149:                 Operator: p.curToken.Literal,
   150:         }
=> 151:         p.nextToken()
   152:         expression.Right = p.parseExpression(PREFIX)
   153:         return expression
   154: }
   155:
   156: // parseLetStatement 変数宣言の構文チェックをする
(dlv) n

// 次のtokenをPREFIXとして解釈する
> app/parser.(*Parser).parsePrefixExpression() ./parser.go:152 (PC: 0x10f3dd2)
   147:         expression := &ast.PrefixExpression{
   148:                 Token:    p.curToken,
   149:                 Operator: p.curToken.Literal,
   150:         }
   151:         p.nextToken()
=> 152:         expression.Right = p.parseExpression(PREFIX)
   153:         return expression
   154: }
   155:
   156: // parseLetStatement 変数宣言の構文チェックをする
   157: func (p *Parser) parseLetStatement() *ast.LetStatement {
(dlv) s

// 次にあるtokenはaという変数
> app/parser.(*Parser).parseExpression() ./parser.go:249 (PC: 0x10f4e99)
   244: }
   245:
   246: // parseExpression 現在のtokenが特別な振る舞いを持つ場合、関数値にする
   247: // 現在のtokenの次にあるtokenもまた同様に調べる
   248: func (p *Parser) parseExpression(precedence int) ast.Expression {
=> 249:         prefix := p.prefixParseFns[p.curToken.Type]
   250:         if prefix == nil {
   251:                 p.noPrefixParseFnError(p.curToken.Type)
   252:                 return nil
   253:         }
   254:         leftExp := prefix()
(dlv) p p.curToken
app/token.Token {Type: "IDENT", Literal: "a"}

// 変数としての振る舞いを持たせる
> app/parser.(*Parser).parseExpression() ./parser.go:254 (PC: 0x10f4ef3)
   249:         prefix := p.prefixParseFns[p.curToken.Type]
   250:         if prefix == nil {
   251:                 p.noPrefixParseFnError(p.curToken.Type)
   252:                 return nil
   253:         }
=> 254:         leftExp := prefix()
   255:
   256:         for !p.peekTokenIs(token.SEMICOLON) && precedence < p.peekPrecedence()
 {
   257:                 infix := p.infixParseFns[p.peekToken.Type]
   258:                 if infix == nil {
   259:                         return leftExp
(dlv) s
> app/parser.(*Parser).(app/parser.parseIdentifier)-fm() ./parser.go:64 (PC: 0x10f99cf
)
    59:                 l:      l,
    60:                 errors: []string{},
    61:         }
    62:
    63:         p.prefixParseFns = make(map[token.TokenType]prefixParseFn)
=>  64:         p.registerPrefix(token.IDENT, p.parseIdentifier)
    65:         p.registerPrefix(token.INT, p.parseIntegerLiteral)
    66:         p.registerPrefix(token.BANG, p.parsePrefixExpression)
    67:         p.registerPrefix(token.MINUS, p.parsePrefixExpression)
    68:         // p.registerPrefix(token.TRUE, p.parseBoolean)
    69:         // p.registerPrefix(token.FALSE, p.parseBoolean)
(dlv)

// 変数としてastに情報を格納する
> app/parser.(*Parser).parseIdentifier() ./parser.go:243 (PC: 0x10f4d63)
   238:         expression.Right = p.parseExpression(precedence)
   239:         return expression
   240: }
   241:
   242: func (p *Parser) parseIdentifier() ast.Expression {
=> 243:         return &ast.Identifier{Token: p.curToken, Value: p.curToken.Literal}
   244: }
   245:
   246: // parseExpression 現在のtokenが特別な振る舞いを持つ場合、関数値にする
   247: // 現在のtokenの次にあるtokenもまた同様に調べる
   248: func (p *Parser) parseExpression(precedence int) ast.Expression {
(dlv) p ast

// もし次のtokenがセミコロン　または優先度の高い処理であれば次にいく
=> 256:         for !p.peekTokenIs(token.SEMICOLON) && precedence < p.peekPrecedence(
 {
   257:                 infix := p.infixParseFns[p.peekToken.Type]
   258:                 if infix == nil {
   259:                         return leftExp
   260:                 }
   261:                 p.nextToken()
(dlv)
> app/parser.(*Parser).parseExpression() ./parser.go:264 (PC: 0x10f5030)
   259:                         return leftExp
   260:                 }
   261:                 p.nextToken()
   262:                 leftExp = infix(leftExp)
   263:         }
=> 264:         return leftExp
   265: }
   266:
   267: // curTokenIs 引数のtokenTypeと現在のcurTokenのtypeが同じか調べる
   268: func (p *Parser) curTokenIs(t token.TokenType) bool {
   269:         return p.curToken.Type == t
(dlv)

// 処理完了後の状態
(dlv) p expression
*app/ast.PrefixExpression {
        Token: app/token.Token {Type: "-", Literal: "-"},
        Operator: "-",
        Right: app/ast.Expression(*app/ast.Identifier) *{
                Token: (*app/token.Token)(0xc4200798c0),
                Value: "a",},}
(dlv)
```
